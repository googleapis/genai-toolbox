# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

name: 'ðŸ“‹ Gemini Scheduled Issue Triage'

on:
  schedule:
    - cron: '0 0 * * *' # Runs everyday at midnight
  workflow_dispatch:

concurrency:
  group: '${{ github.workflow }}'
  cancel-in-progress: true

defaults:
  run:
    shell: 'bash'

permissions:
  id-token: 'write'
  issues: 'write'

jobs:
  triage-issues:
    timeout-minutes: 10
    if: |-
      ${{ github.repository == 'google-gemini/gemini-cli' }}
    runs-on: 'ubuntu-latest'
    steps:
      - name: 'Checkout'
        uses: 'actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8' # ratchet:actions/checkout@v5

      - name: 'Generate GitHub App Token'
        id: 'generate_token'
        uses: 'actions/create-github-app-token@a8d616148505b5069dccd32f177bb87d7f39123b' # ratchet:actions/create-github-app-token@v2
        with:
          app-id: '${{ secrets.APP_ID }}'
          private-key: '${{ secrets.PRIVATE_KEY }}'
          permission-issues: 'write'

      - name: 'Find untriaged issues'
        id: 'find_issues'
        env:
          GITHUB_TOKEN: '${{ steps.generate_token.outputs.token }}'
          GITHUB_REPOSITORY: '${{ github.repository }}'
        run: |-
          set -euo pipefail

          echo 'ðŸ” Finding issues without labels...'
          NO_LABEL_ISSUES="$(gh issue list --repo "${GITHUB_REPOSITORY}" \
            --search 'is:open is:issue no:label' --json number,title,body)"

          echo 'ðŸ·ï¸ Finding issues that need triage...'
          NEED_TRIAGE_ISSUES="$(gh issue list --repo "${GITHUB_REPOSITORY}" \
            --search "is:open is:issue label:\"status: need-triage\""  --limit 1000 --json number,title,body)"

          echo 'ðŸ”„ Merging and deduplicating issues...'
          ISSUES="$(echo "${NO_LABEL_ISSUES}" "${NEED_TRIAGE_ISSUES}" | jq -c -s 'add | unique_by(.number)')"

          echo 'ðŸ“ Setting output for GitHub Actions...'
          echo "issues_to_triage=${ISSUES}" >> "${GITHUB_OUTPUT}"

          ISSUE_COUNT="$(echo "${ISSUES}" | jq 'length')"
          echo "âœ… Found ${ISSUE_COUNT} issues to triage! ðŸŽ¯"

      - name: 'Get Repository Labels'
        id: 'get_labels'
        uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea'
        with:
          github-token: '${{ steps.generate_token.outputs.token }}'
          script: |-
            const { data: labels } = await github.rest.issues.listLabelsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const labelNames = labels.map(label => label.name);
            core.setOutput('available_labels', labelNames.join(','));
            core.info(`Found ${labelNames.length} labels: ${labelNames.join(', ')}`);
            return labelNames;

      - name: 'Run Gemini Issue Analysis'
        if: |-
          ${{ steps.find_issues.outputs.issues_to_triage != '[]' }}
        uses: 'google-github-actions/run-gemini-cli@a3bf79042542528e91937b3a3a6fbc4967ee3c31' # ratchet:google-github-actions/run-gemini-cli@v0
        id: 'gemini_issue_analysis'
        env:
          GITHUB_TOKEN: '' # Do not pass any auth token here since this runs on untrusted inputs
          ISSUES_TO_TRIAGE: '${{ steps.find_issues.outputs.issues_to_triage }}'
          REPOSITORY: '${{ github.repository }}'
          AVAILABLE_LABELS: '${{ steps.get_labels.outputs.available_labels }}'
        with:
          gcp_workload_identity_provider: '${{ vars.GCP_WIF_PROVIDER }}'
          gcp_project_id: '${{ vars.GOOGLE_CLOUD_PROJECT }}'
          gcp_location: '${{ vars.GOOGLE_CLOUD_LOCATION }}'
          gcp_service_account: '${{ vars.SERVICE_ACCOUNT_EMAIL }}'
          gemini_api_key: '${{ secrets.GEMINI_API_KEY }}'
          use_vertex_ai: '${{ vars.GOOGLE_GENAI_USE_VERTEXAI }}'
          use_gemini_code_assist: '${{ vars.GOOGLE_GENAI_USE_GCA }}'
          settings: |-
            {
              "maxSessionTurns": 25,
              "coreTools": [
                "run_shell_command(echo)"
              ],
              "telemetry": {
                "enabled": true,
                "target": "gcp"
              }
            }
          prompt: |-
            ## Role

            You are an issue triage assistant. Analyze issues and identify
            appropriate labels. Use the available tools to gather information;
            do not ask for information to be provided.

            ## Steps

            1. You are only able to use the echo command. Review the available labels in the environment variable: "${AVAILABLE_LABELS}".
            2. Check environment variable for issues to triage: $ISSUES_TO_TRIAGE (JSON array of issues)
            3. Review the issue title, body and any comments provided in the environment variables.
            4. Identify the most relevant labels from the existing labels,
            focusing on priority: *, type: *, and product: *.
            5. If the issue already has product: label, dont try to change it.
            If the issue already has a priority: label do not change it. If the
            issue alrady has a type: label do not change it. for example:
               If an issue has product: alloydb,  you will only add a type:
               and/or priority: label.
               Instead if an issue has no labels, you will could add one lable of each kind.
            6. For product: limit yourself to only the single most applicable label in each case.
            7. Give me a single short explanation about why you are selecting each label in the process.
            8. Output a JSON array of objects, each containing the issue number
               and the labels to add and remove, along with an explanation. For example:
               ```
               [
                 {
                   "issue_number": 123,
                   "labels_to_add": ["product: alloydb", "priority: p2"],
                   "labels_to_remove": ["status: need-triage"],
                   "explanation": "This issue is a bug within the alloydb tool that needs to be addressed with medium priority."
                 }
               ]
               ```
              If an issue cannot be classified, do not include it in the output array.
            9. If you see that the issue doesn't look like it has sufficient information, leave a comment politely requesting the relevant information, eg.. if repro steps are missing request for repro steps. if version information is missing request for version information into the explanation section below.
              - After identifying appropriate labels to an issue, add "status: need-triage" label to labels_to_remove in the output.
            10. If you think an issue might be a Priority: P0 do not apply the priority: p0 label. Instead apply a status: manual-triage label and include a note in your explanation.
            11. If you are uncertain and have not been able to apply one each of product:, type: and priority: , apply the status: manual-triage label.

            ## Guidelines

            - Output only valid JSON format
            - Do not include any explanation or additional text, just the JSON
            - Only use labels that already exist in the repository.
              - Do not add comments or modify the issue content.
              - Do not remove the following labels maintainer, help wanted or good first issue.
              - Triage only the current issue.
              - Identify only one product: label
              - Identify applicable priority:* labels based on the issue content.
              - Once you categorize the issue if it needs information bump down the priority by 1 eg.. a p0 would become a p1 a p1 would become a p2. P2 and P3 can stay as is in this scenario.
            Categorization Guidelines:
            P0: Critical / Blocker
              - A P0 bug is a catastrophic failure that demands immediate attention.
              - To be a P0 it means almost all users are running into this issue and it is blocking users from being able to use the product.
              - You would see this in the form of many comments from different developers on the bug.
              - It represents a complete showstopper for a significant portion of users or for the development process itself.
            Impact:
              - Blocks development or testing for the entire team.
              - Major security vulnerability that could compromise user data or system integrity.
              - Causes data loss or corruption with no workaround.
              - Crashes the application or makes a core feature completely unusable for all or most users in a production environment. Will it cause severe quality degration?
              - Is it preventing contributors from contributing to the repository or is it a release blocker?
              Qualifier: Is the main function of the server broken?
              Example: The toolbox server fails with an unrecoverable error, preventing any user from authenticating and connecting to the database.
            P1: High
              - A P1 bug is a serious issue that significantly degrades the user experience or impacts a core feature.
              - While not a complete blocker, it's a major problem that needs a fast resolution. Feature requests are almost never P1.
              - Once again this would be affecting many users.
              - You would see this in the form of comments from different developers on the bug.
              Impact:
              - A core feature is broken or behaving incorrectly for a large number of users or large number of use cases.
              - Review the bug details and comments to try figure out if this issue affects a large set of use cases or if it's a narrow set of use cases.
              - Severe performance degradation making the application frustratingly slow.
              - No straightforward workaround exists, or the workaround is difficult and non-obvious.
              Qualifier: Is a key feature unusable or giving very wrong results?
              Example: Oracle tool invocation with DML statement raises error.
            P2: Medium
              - A P2 bug is a moderately impactful issue. It's a noticeable problem but doesn't prevent the use of the software's main functionality.
              Impact:
              - Affects a non-critical feature or a smaller, specific subset of users.
              - An inconvenient but functional workaround is available and easy to execute.
              - Noticeable UI/UX problems that don't break functionality but look unprofessional (e.g., elements are misaligned or overlapping).
              Qualifier: Is it an annoying but non-blocking problem?
              Example: An error message is unclear or contains a typo, causing user confusion but not halting their workflow.
            P3: Low
              - A P3 bug is a minor, low-impact issue that is trivial or cosmetic. It has little to no effect on the overall functionality of the application.
              Impact:
              - Minor cosmetic issues like color inconsistencies, typos in documentation, or slight alignment problems on a non-critical page.
              - An edge-case bug that is very difficult to reproduce and affects a tiny fraction of users.
              Qualifier: Is it a "nice-to-fix" issue?
              Example: Spelling mistakes etc.
            Definition of Areas
            product: alloydb
            - Description: Issues related to the alloydb source or tools.
            product: bigquery
            - Description: Issues related to the bigquery source or tools.
            product: bigtable
            - Description: Issues related to the bigtable source or tools.
            product: cassandra
            - Description: Issues related to the cassandra source or tools.
            product: clickhouse
            - Description: Issues related to the clickhouse source or tools.
            product: mssql
            - Description: Issues related to the mssql source or tools.
            product: mysql
            - Description: Issues related to the mysql source or tools.
            product: postgres
            - Description: Issues related to the postgres source or tools.
            product: couchbase
            - Description: Issues related to the couchbase source or tools.
            product: dataplex
            - Description: Issues related to the dataplex source or tools.
            product: dgraph
            - Description: Issues related to the dgraph source or tools.
            product: elasticsearch
            - Description: Issues related to the elasticsearch source or tools.
            product: firebird
            - Description: Issues related to the firebird source or tools.
            product: firestore
            - Description: Issues related to the firestore source or tools.
            product: looker
            - Description: Issues related to the looker source or tools.
            product: mindsdb
            - Description: Issues related to the mindsdb source or tools.
            product: mongodb
            - Description: Issues related to the mongodb source or tools.
            product: neo4j
            - Description: Issues related to the neo4j source or tools.
            product: oceanbase
            - Description: Issues related to the oceanbase source or tools.
            product: oracle
            - Description: Issues related to the oracle source or tools.
            product: redis
            - Description: Issues related to the redis source or tools.
            product: serverlessspark
            - Description: Issues related to the serverlessspark source or tools.
            product: singlestore
            - Description: Issues related to the singlestore source or tools.
            product: spanner
            - Description: Issues related to the spanner source or tools.
            product: sqlite
            - Description: Issues related to the sqlite source or tools.
            product: tidb
            - Description: Issues related to the tidb source or tools.
            product: trino
            - Description: Issues related to the trino source or tools.
            product: valkey
            - Description: Issues related to the valkey source or tools.
            product: yugabytedb
            - Description: Issues related to the yugabytedb source or tools.
            product: unknown
            - Description: Issues that do not clearly fit into any other defined product: category, or where information is too limited to make a determination. Use this when no other product is appropriate.

      - name: 'Apply Labels to Issues'
        if: |-
          ${{ steps.gemini_issue_analysis.outcome == 'success' &&
              steps.gemini_issue_analysis.outputs.summary != '[]' }}
        env:
          REPOSITORY: '${{ github.repository }}'
          LABELS_OUTPUT: '${{ steps.gemini_issue_analysis.outputs.summary }}'
        uses: 'actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea'
        with:
          github-token: '${{ steps.generate_token.outputs.token }}'
          script: |-
            const rawLabels = process.env.LABELS_OUTPUT;
            core.info(`Raw labels JSON: ${rawLabels}`);
            let parsedLabels;
            try {
              const jsonMatch = rawLabels.match(/```json\s*([\s\S]*?)\s*```/);
              if (!jsonMatch || !jsonMatch[1]) {
                throw new Error("Could not find a ```json ... ``` block in the output.");
              }
              const jsonString = jsonMatch[1].trim();
              parsedLabels = JSON.parse(jsonString);
              core.info(`Parsed labels JSON: ${JSON.stringify(parsedLabels)}`);
            } catch (err) {
              core.setFailed(`Failed to parse labels JSON from Gemini output: ${err.message}\nRaw output: ${rawLabels}`);
              return;
            }

            for (const entry of parsedLabels) {
              const issueNumber = entry.issue_number;
              if (!issueNumber) {
                core.info(`Skipping entry with no issue number: ${JSON.stringify(entry)}`);
                continue;
              }

              if (labelsToAdd.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  labels: labelsToAdd
                });
                const explanation = entry.explanation ? ` - ${entry.explanation}` : '';
                core.info(`Successfully added labels for #${issueNumber}: ${labelsToAdd.join(', ')}${explanation}`);
              }

              if (entry.labels_to_remove && entry.labels_to_remove.length > 0) {
                for (const label of entry.labels_to_remove) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      name: label
                    });
                  } catch (error) {
                    if (error.status !== 404) {
                      throw error;
                    }
                  }
                }
                core.info(`Successfully removed labels for #${issueNumber}: ${entry.labels_to_remove.join(', ')}`);
              }

              if (entry.explanation) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                  body: entry.explanation,
                });
              }

              if ((!entry.labels_to_add || entry.labels_to_add.length === 0) && (!entry.labels_to_remove || entry.labels_to_remove.length === 0)) {
                core.info(`No labels to add or remove for #${issueNumber}, leaving as is`);
              }
            }
